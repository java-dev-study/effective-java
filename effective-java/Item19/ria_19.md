### 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

#### 문서화

- 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
- `@implSpec` 태그를 사용해 API 문서에 해당 메서드의 내부 동작 방식을 설명해야 한다.

#### protected 제공

- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
- Protected 하나하나가 내부 구현에 해당하므로 가능한 적게 하면서, 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다.

#### 추가 제약

- 상속용 클래스의 생성자는 직접적이든 간접적이든 재정의 가능 메서드를 호출해서는 안된다.
- clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
- Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private이 아닌 protected로 선언해야 한다.

#### 일반적인 구체 클래스

- 상속용으로 설계하지 않은 클래스는 상속을 금지한다.

​	**상속을 금지하는 방법**

	- 클래스를 final로 선언한다.
	- 모든 생성자를 private나 package-private으로 선언하고 public 정적 팩터리를 만들어 준다.

#### 정리

- 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 한다.
- 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다.
- 클래스를 확장할 이유가 불분명하다면 상속을 금지해야 한다.
- 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 한다.